#!/usr/bin/env python3

"""Demonstrates the use of generator expressions and generator functions in Python.

This module explores various ways to create and use generators, including:
- Generator expressions vs list comprehensions
- Memory efficiency of generators
- Creating generator functions with yield
- Type hints with generators
- Practical examples using strings and numbers

Examples include:
- Generating large number sequences
- Filtering strings by length
- Custom sequence generators
- Length calculations for character sequences
"""

from typing import NewType, List

# Define a custom type for non-negative integers
NonNegativeInt = NewType("NonNegativeInt", int)

# Generators vs. list comprehensions
# nums_huge = [num for num in range(10 ** 1000000)]  # takes up a huge amount of memory
nums_huge_generator = (num for num in range(10**1000000))
print(type(nums_huge_generator))
print(next(nums_huge_generator))
print(next(nums_huge_generator))
print(next(nums_huge_generator))


# Generator functions
def num_sequence(n: NonNegativeInt) -> int:
    """Generate a sequence of integers from 0 to n-1.

    Args:
        n (NonNegativeInt): The upper bound (exclusive) of the sequence. Must be non-negative.

    Yields:
        int: The next integer in the sequence.

    Raises:
        ValueError: If n is negative.
    """
    if n < 0:
        raise ValueError("n must be non-negative")
    i = 0
    while i < n:
        yield i
        i += 1


result = num_sequence(NonNegativeInt(5))
print(f"result is a: {type(result)}")  # Shows it's a generator object
print(f"First value: {next(result)}")  # 0
print(f"Second value: {next(result)}")  # 1
print(f"Third value: {next(result)}")  # 2

# We can also use it in a for loop
print("\nUsing for loop:")
for num in num_sequence(NonNegativeInt(3)):
    print(num)


# Compare with a function that returns a generator
def make_generator(n: NonNegativeInt):
    """Returns a generator expression.

    Args:
        n (NonNegativeInt): The upper bound (exclusive) of the sequence. Must be non-negative.

    Returns:
        generator: A generator expression for numbers 0 to n-1.

    Raises:
        ValueError: If n is negative.
    """
    if n < 0:
        raise ValueError("n must be non-negative")
    return (i for i in range(n))  # This returns a generator expression


gen = make_generator(NonNegativeInt(5))
print(f"\nmake_generator returns: {type(gen)}")

# List of strings
fellowship = ["frodo", "samwise", "merry", "aragorn", "legolas", "boromir", "gimli"]
# List comprehension
fellow1 = [member for member in fellowship if len(member) >= 7]
# Generator expression
fellow2 = (member for member in fellowship if len(member) >= 7)

# Try to play around with fellow1 and fellow2 by figuring out their types and
# printing out their values.
print(f"fellow1\ntype: {type(fellow1)}\nvalue: {fellow1}")
print(f"fellow2\ntype: {type(fellow2)}\nvalue: {fellow2}")

# Create a generator object that will produce values from 0 to 30.
# Assign the result to result and use num as the iterator variable in the generator expression.
num_generator = (num for num in range(31))

# Print the first 5 values by using next() appropriately in print().
for i in range(5):
    print(next(num_generator))

# Print the rest of the values by using a for loop to iterate over the generator object.
for value in num_generator:
    print(value)


# Create a list of strings: lannister
lannister = ["cersei", "jaime", "tywin", "tyrion", "joffrey"]

# Create a generator object: lengths
lengths = (len(name) for name in lannister)

# Iterate over and print the values in lengths
for value in lengths:
    print(value)


# Define generator function get_lengths
def get_lengths(input_list: List):
    """Generator function that yields the
    length of the strings in input_list."""

    # Yield the length of a string
    for person in input_list:
        yield len(person)


# Print the values generated by get_lengths()
for value in get_lengths(lannister):
    print(value)
